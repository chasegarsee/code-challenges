

## Load testing

[-] Load testing is a type of non-functional testing. It is a type of
software testing which is conducted to understand the behavior of 
the application under a specific expected load. It is performed 
to determine a systemâ€™s behavior under both normal and at peak conditions.

[-] It is used to identify whether the infrastructure used for hosting 
the application is sufficient or not

[-] It tells us how many simultaneous users can the application handle and the 
scale of the application required in terms of hardware, network capacity etc., 
so that more users could access the application

[-] It helps to identify the maximum operating capacity of an application as 
well as any bottlenecks and determine which element is causing degradation

## Unit testing

[-] A unit test typically comprises of three stages: plan, cases and scripting, 
and the unit test itself. In the first step, the unit test is prepared and reviewed. 
The next step is for the test cases and scripts to be made, then the code is tested.

[-] Test-driven development requires that developers first write failing unit tests. 
Then they write code and refactor the application until the test passes. 

[-] TDD typically results in an explicit and predictable code base.

## Functional testing

[-] Functional testing is a quality assurance (QA) process and a type of black-box testing that bases its test cases on the specifications of the software component under test. Functions are tested by feeding them input and examining the output, and internal program structure is rarely considered (unlike white-box testing). Functional testing is conducted to evaluate the compliance of a system or component with specified functional requirements. Functional testing usually describes what the system does.

[-] Since functional testing is a type of black-box testing, the software's functionality can be tested without knowing the internal workings of the software. This means that testers do not need to know programming languages or how the software has been implemented. This, in turn, could lead to reduced developer-bias (or confirmation bias) in testing since the tester has not been involved in the software's development.[4]

## Regression testing

## Maintain continuous integration testing suites

## Create and execute testing plans.